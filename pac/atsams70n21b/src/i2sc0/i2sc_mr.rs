#[doc = r" Value read from the register"]
pub struct R {
    bits: u32,
}
#[doc = r" Value to write to the register"]
pub struct W {
    bits: u32,
}
impl super::I2SC_MR {
    #[doc = r" Modifies the contents of the register"]
    #[inline]
    pub fn modify<F>(&self, f: F)
    where
        for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
    {
        let bits = self.register.get();
        let r = R { bits: bits };
        let mut w = W { bits: bits };
        f(&r, &mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Reads the contents of the register"]
    #[inline]
    pub fn read(&self) -> R {
        R {
            bits: self.register.get(),
        }
    }
    #[doc = r" Writes to the register"]
    #[inline]
    pub fn write<F>(&self, f: F)
    where
        F: FnOnce(&mut W) -> &mut W,
    {
        let mut w = W::reset_value();
        f(&mut w);
        self.register.set(w.bits);
    }
    #[doc = r" Writes the reset value to the register"]
    #[inline]
    pub fn reset(&self) {
        self.write(|w| w)
    }
}
#[doc = "Possible values of the field `MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum MODER {
    #[doc = "I2SC_CK and I2SC_WS pin inputs used as bit clock and word select/frame synchronization."]
    SLAVE,
    #[doc = "Bit clock and word select/frame synchronization generated by I2SC from MCK and output to I2SC_CK and I2SC_WS pins. Peripheral clock or GCLK is output as master clock on I2SC_MCK if I2SC_MR.IMCKMODE is set."]
    MASTER,
}
impl MODER {
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        match *self {
            MODER::SLAVE => false,
            MODER::MASTER => true,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: bool) -> MODER {
        match value {
            false => MODER::SLAVE,
            true => MODER::MASTER,
        }
    }
    #[doc = "Checks if the value of the field is `SLAVE`"]
    #[inline]
    pub fn is_slave(&self) -> bool {
        *self == MODER::SLAVE
    }
    #[doc = "Checks if the value of the field is `MASTER`"]
    #[inline]
    pub fn is_master(&self) -> bool {
        *self == MODER::MASTER
    }
}
#[doc = "Possible values of the field `DATALENGTH`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DATALENGTHR {
    #[doc = "Data length is set to 32 bits"]
    _32_BITS,
    #[doc = "Data length is set to 24 bits"]
    _24_BITS,
    #[doc = "Data length is set to 20 bits"]
    _20_BITS,
    #[doc = "Data length is set to 18 bits"]
    _18_BITS,
    #[doc = "Data length is set to 16 bits"]
    _16_BITS,
    #[doc = "Data length is set to 16-bit compact stereo. Left sample in bits 15:0 and right sample in bits 31:16 of same word."]
    _16_BITS_COMPACT,
    #[doc = "Data length is set to 8 bits"]
    _8_BITS,
    #[doc = "Data length is set to 8-bit compact stereo. Left sample in bits 7:0 and right sample in bits 15:8 of the same word."]
    _8_BITS_COMPACT,
}
impl DATALENGTHR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        match *self {
            DATALENGTHR::_32_BITS => 0,
            DATALENGTHR::_24_BITS => 1,
            DATALENGTHR::_20_BITS => 2,
            DATALENGTHR::_18_BITS => 3,
            DATALENGTHR::_16_BITS => 4,
            DATALENGTHR::_16_BITS_COMPACT => 5,
            DATALENGTHR::_8_BITS => 6,
            DATALENGTHR::_8_BITS_COMPACT => 7,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: u8) -> DATALENGTHR {
        match value {
            0 => DATALENGTHR::_32_BITS,
            1 => DATALENGTHR::_24_BITS,
            2 => DATALENGTHR::_20_BITS,
            3 => DATALENGTHR::_18_BITS,
            4 => DATALENGTHR::_16_BITS,
            5 => DATALENGTHR::_16_BITS_COMPACT,
            6 => DATALENGTHR::_8_BITS,
            7 => DATALENGTHR::_8_BITS_COMPACT,
            _ => unreachable!(),
        }
    }
    #[doc = "Checks if the value of the field is `_32_BITS`"]
    #[inline]
    pub fn is_32_bits(&self) -> bool {
        *self == DATALENGTHR::_32_BITS
    }
    #[doc = "Checks if the value of the field is `_24_BITS`"]
    #[inline]
    pub fn is_24_bits(&self) -> bool {
        *self == DATALENGTHR::_24_BITS
    }
    #[doc = "Checks if the value of the field is `_20_BITS`"]
    #[inline]
    pub fn is_20_bits(&self) -> bool {
        *self == DATALENGTHR::_20_BITS
    }
    #[doc = "Checks if the value of the field is `_18_BITS`"]
    #[inline]
    pub fn is_18_bits(&self) -> bool {
        *self == DATALENGTHR::_18_BITS
    }
    #[doc = "Checks if the value of the field is `_16_BITS`"]
    #[inline]
    pub fn is_16_bits(&self) -> bool {
        *self == DATALENGTHR::_16_BITS
    }
    #[doc = "Checks if the value of the field is `_16_BITS_COMPACT`"]
    #[inline]
    pub fn is_16_bits_compact(&self) -> bool {
        *self == DATALENGTHR::_16_BITS_COMPACT
    }
    #[doc = "Checks if the value of the field is `_8_BITS`"]
    #[inline]
    pub fn is_8_bits(&self) -> bool {
        *self == DATALENGTHR::_8_BITS
    }
    #[doc = "Checks if the value of the field is `_8_BITS_COMPACT`"]
    #[inline]
    pub fn is_8_bits_compact(&self) -> bool {
        *self == DATALENGTHR::_8_BITS_COMPACT
    }
}
#[doc = r" Value of the field"]
pub struct RXMONOR {
    bits: bool,
}
impl RXMONOR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct RXDMAR {
    bits: bool,
}
impl RXDMAR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct RXLOOPR {
    bits: bool,
}
impl RXLOOPR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct TXMONOR {
    bits: bool,
}
impl TXMONOR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct TXDMAR {
    bits: bool,
}
impl TXDMAR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct TXSAMER {
    bits: bool,
}
impl TXSAMER {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct IMCKDIVR {
    bits: u8,
}
impl IMCKDIVR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        self.bits
    }
}
#[doc = "Possible values of the field `IMCKFS`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum IMCKFSR {
    #[doc = "Sample frequency ratio set to 32"]
    M2SF32,
    #[doc = "Sample frequency ratio set to 64"]
    M2SF64,
    #[doc = "Sample frequency ratio set to 96"]
    M2SF96,
    #[doc = "Sample frequency ratio set to 128"]
    M2SF128,
    #[doc = "Sample frequency ratio set to 192"]
    M2SF192,
    #[doc = "Sample frequency ratio set to 256"]
    M2SF256,
    #[doc = "Sample frequency ratio set to 384"]
    M2SF384,
    #[doc = "Sample frequency ratio set to 512"]
    M2SF512,
    #[doc = "Sample frequency ratio set to 768"]
    M2SF768,
    #[doc = "Sample frequency ratio set to 1024"]
    M2SF1024,
    #[doc = "Sample frequency ratio set to 1536"]
    M2SF1536,
    #[doc = "Sample frequency ratio set to 2048"]
    M2SF2048,
    #[doc = r" Reserved"]
    _Reserved(u8),
}
impl IMCKFSR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bits(&self) -> u8 {
        match *self {
            IMCKFSR::M2SF32 => 0,
            IMCKFSR::M2SF64 => 1,
            IMCKFSR::M2SF96 => 2,
            IMCKFSR::M2SF128 => 3,
            IMCKFSR::M2SF192 => 5,
            IMCKFSR::M2SF256 => 7,
            IMCKFSR::M2SF384 => 11,
            IMCKFSR::M2SF512 => 15,
            IMCKFSR::M2SF768 => 23,
            IMCKFSR::M2SF1024 => 31,
            IMCKFSR::M2SF1536 => 47,
            IMCKFSR::M2SF2048 => 63,
            IMCKFSR::_Reserved(bits) => bits,
        }
    }
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _from(value: u8) -> IMCKFSR {
        match value {
            0 => IMCKFSR::M2SF32,
            1 => IMCKFSR::M2SF64,
            2 => IMCKFSR::M2SF96,
            3 => IMCKFSR::M2SF128,
            5 => IMCKFSR::M2SF192,
            7 => IMCKFSR::M2SF256,
            11 => IMCKFSR::M2SF384,
            15 => IMCKFSR::M2SF512,
            23 => IMCKFSR::M2SF768,
            31 => IMCKFSR::M2SF1024,
            47 => IMCKFSR::M2SF1536,
            63 => IMCKFSR::M2SF2048,
            i => IMCKFSR::_Reserved(i),
        }
    }
    #[doc = "Checks if the value of the field is `M2SF32`"]
    #[inline]
    pub fn is_m2sf32(&self) -> bool {
        *self == IMCKFSR::M2SF32
    }
    #[doc = "Checks if the value of the field is `M2SF64`"]
    #[inline]
    pub fn is_m2sf64(&self) -> bool {
        *self == IMCKFSR::M2SF64
    }
    #[doc = "Checks if the value of the field is `M2SF96`"]
    #[inline]
    pub fn is_m2sf96(&self) -> bool {
        *self == IMCKFSR::M2SF96
    }
    #[doc = "Checks if the value of the field is `M2SF128`"]
    #[inline]
    pub fn is_m2sf128(&self) -> bool {
        *self == IMCKFSR::M2SF128
    }
    #[doc = "Checks if the value of the field is `M2SF192`"]
    #[inline]
    pub fn is_m2sf192(&self) -> bool {
        *self == IMCKFSR::M2SF192
    }
    #[doc = "Checks if the value of the field is `M2SF256`"]
    #[inline]
    pub fn is_m2sf256(&self) -> bool {
        *self == IMCKFSR::M2SF256
    }
    #[doc = "Checks if the value of the field is `M2SF384`"]
    #[inline]
    pub fn is_m2sf384(&self) -> bool {
        *self == IMCKFSR::M2SF384
    }
    #[doc = "Checks if the value of the field is `M2SF512`"]
    #[inline]
    pub fn is_m2sf512(&self) -> bool {
        *self == IMCKFSR::M2SF512
    }
    #[doc = "Checks if the value of the field is `M2SF768`"]
    #[inline]
    pub fn is_m2sf768(&self) -> bool {
        *self == IMCKFSR::M2SF768
    }
    #[doc = "Checks if the value of the field is `M2SF1024`"]
    #[inline]
    pub fn is_m2sf1024(&self) -> bool {
        *self == IMCKFSR::M2SF1024
    }
    #[doc = "Checks if the value of the field is `M2SF1536`"]
    #[inline]
    pub fn is_m2sf1536(&self) -> bool {
        *self == IMCKFSR::M2SF1536
    }
    #[doc = "Checks if the value of the field is `M2SF2048`"]
    #[inline]
    pub fn is_m2sf2048(&self) -> bool {
        *self == IMCKFSR::M2SF2048
    }
}
#[doc = r" Value of the field"]
pub struct IMCKMODER {
    bits: bool,
}
impl IMCKMODER {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = r" Value of the field"]
pub struct IWSR {
    bits: bool,
}
impl IWSR {
    #[doc = r" Value of the field as raw bits"]
    #[inline]
    pub fn bit(&self) -> bool {
        self.bits
    }
    #[doc = r" Returns `true` if the bit is clear (0)"]
    #[inline]
    pub fn bit_is_clear(&self) -> bool {
        !self.bit()
    }
    #[doc = r" Returns `true` if the bit is set (1)"]
    #[inline]
    pub fn bit_is_set(&self) -> bool {
        self.bit()
    }
}
#[doc = "Values that can be written to the field `MODE`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum MODEW {
    #[doc = "I2SC_CK and I2SC_WS pin inputs used as bit clock and word select/frame synchronization."]
    SLAVE,
    #[doc = "Bit clock and word select/frame synchronization generated by I2SC from MCK and output to I2SC_CK and I2SC_WS pins. Peripheral clock or GCLK is output as master clock on I2SC_MCK if I2SC_MR.IMCKMODE is set."]
    MASTER,
}
impl MODEW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> bool {
        match *self {
            MODEW::SLAVE => false,
            MODEW::MASTER => true,
        }
    }
}
#[doc = r" Proxy"]
pub struct _MODEW<'a> {
    w: &'a mut W,
}
impl<'a> _MODEW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: MODEW) -> &'a mut W {
        {
            self.bit(variant._bits())
        }
    }
    #[doc = "I2SC_CK and I2SC_WS pin inputs used as bit clock and word select/frame synchronization."]
    #[inline]
    pub fn slave(self) -> &'a mut W {
        self.variant(MODEW::SLAVE)
    }
    #[doc = "Bit clock and word select/frame synchronization generated by I2SC from MCK and output to I2SC_CK and I2SC_WS pins. Peripheral clock or GCLK is output as master clock on I2SC_MCK if I2SC_MR.IMCKMODE is set."]
    #[inline]
    pub fn master(self) -> &'a mut W {
        self.variant(MODEW::MASTER)
    }
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 0;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `DATALENGTH`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DATALENGTHW {
    #[doc = "Data length is set to 32 bits"]
    _32_BITS,
    #[doc = "Data length is set to 24 bits"]
    _24_BITS,
    #[doc = "Data length is set to 20 bits"]
    _20_BITS,
    #[doc = "Data length is set to 18 bits"]
    _18_BITS,
    #[doc = "Data length is set to 16 bits"]
    _16_BITS,
    #[doc = "Data length is set to 16-bit compact stereo. Left sample in bits 15:0 and right sample in bits 31:16 of same word."]
    _16_BITS_COMPACT,
    #[doc = "Data length is set to 8 bits"]
    _8_BITS,
    #[doc = "Data length is set to 8-bit compact stereo. Left sample in bits 7:0 and right sample in bits 15:8 of the same word."]
    _8_BITS_COMPACT,
}
impl DATALENGTHW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> u8 {
        match *self {
            DATALENGTHW::_32_BITS => 0,
            DATALENGTHW::_24_BITS => 1,
            DATALENGTHW::_20_BITS => 2,
            DATALENGTHW::_18_BITS => 3,
            DATALENGTHW::_16_BITS => 4,
            DATALENGTHW::_16_BITS_COMPACT => 5,
            DATALENGTHW::_8_BITS => 6,
            DATALENGTHW::_8_BITS_COMPACT => 7,
        }
    }
}
#[doc = r" Proxy"]
pub struct _DATALENGTHW<'a> {
    w: &'a mut W,
}
impl<'a> _DATALENGTHW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: DATALENGTHW) -> &'a mut W {
        {
            self.bits(variant._bits())
        }
    }
    #[doc = "Data length is set to 32 bits"]
    #[inline]
    pub fn _32_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_32_BITS)
    }
    #[doc = "Data length is set to 24 bits"]
    #[inline]
    pub fn _24_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_24_BITS)
    }
    #[doc = "Data length is set to 20 bits"]
    #[inline]
    pub fn _20_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_20_BITS)
    }
    #[doc = "Data length is set to 18 bits"]
    #[inline]
    pub fn _18_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_18_BITS)
    }
    #[doc = "Data length is set to 16 bits"]
    #[inline]
    pub fn _16_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_16_BITS)
    }
    #[doc = "Data length is set to 16-bit compact stereo. Left sample in bits 15:0 and right sample in bits 31:16 of same word."]
    #[inline]
    pub fn _16_bits_compact(self) -> &'a mut W {
        self.variant(DATALENGTHW::_16_BITS_COMPACT)
    }
    #[doc = "Data length is set to 8 bits"]
    #[inline]
    pub fn _8_bits(self) -> &'a mut W {
        self.variant(DATALENGTHW::_8_BITS)
    }
    #[doc = "Data length is set to 8-bit compact stereo. Left sample in bits 7:0 and right sample in bits 15:8 of the same word."]
    #[inline]
    pub fn _8_bits_compact(self) -> &'a mut W {
        self.variant(DATALENGTHW::_8_BITS_COMPACT)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 7;
        const OFFSET: u8 = 2;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _RXMONOW<'a> {
    w: &'a mut W,
}
impl<'a> _RXMONOW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 8;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _RXDMAW<'a> {
    w: &'a mut W,
}
impl<'a> _RXDMAW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 9;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _RXLOOPW<'a> {
    w: &'a mut W,
}
impl<'a> _RXLOOPW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 10;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _TXMONOW<'a> {
    w: &'a mut W,
}
impl<'a> _TXMONOW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 12;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _TXDMAW<'a> {
    w: &'a mut W,
}
impl<'a> _TXDMAW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 13;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _TXSAMEW<'a> {
    w: &'a mut W,
}
impl<'a> _TXSAMEW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 14;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _IMCKDIVW<'a> {
    w: &'a mut W,
}
impl<'a> _IMCKDIVW<'a> {
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub unsafe fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 63;
        const OFFSET: u8 = 16;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = "Values that can be written to the field `IMCKFS`"]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum IMCKFSW {
    #[doc = "Sample frequency ratio set to 32"]
    M2SF32,
    #[doc = "Sample frequency ratio set to 64"]
    M2SF64,
    #[doc = "Sample frequency ratio set to 96"]
    M2SF96,
    #[doc = "Sample frequency ratio set to 128"]
    M2SF128,
    #[doc = "Sample frequency ratio set to 192"]
    M2SF192,
    #[doc = "Sample frequency ratio set to 256"]
    M2SF256,
    #[doc = "Sample frequency ratio set to 384"]
    M2SF384,
    #[doc = "Sample frequency ratio set to 512"]
    M2SF512,
    #[doc = "Sample frequency ratio set to 768"]
    M2SF768,
    #[doc = "Sample frequency ratio set to 1024"]
    M2SF1024,
    #[doc = "Sample frequency ratio set to 1536"]
    M2SF1536,
    #[doc = "Sample frequency ratio set to 2048"]
    M2SF2048,
}
impl IMCKFSW {
    #[allow(missing_docs)]
    #[doc(hidden)]
    #[inline]
    pub fn _bits(&self) -> u8 {
        match *self {
            IMCKFSW::M2SF32 => 0,
            IMCKFSW::M2SF64 => 1,
            IMCKFSW::M2SF96 => 2,
            IMCKFSW::M2SF128 => 3,
            IMCKFSW::M2SF192 => 5,
            IMCKFSW::M2SF256 => 7,
            IMCKFSW::M2SF384 => 11,
            IMCKFSW::M2SF512 => 15,
            IMCKFSW::M2SF768 => 23,
            IMCKFSW::M2SF1024 => 31,
            IMCKFSW::M2SF1536 => 47,
            IMCKFSW::M2SF2048 => 63,
        }
    }
}
#[doc = r" Proxy"]
pub struct _IMCKFSW<'a> {
    w: &'a mut W,
}
impl<'a> _IMCKFSW<'a> {
    #[doc = r" Writes `variant` to the field"]
    #[inline]
    pub fn variant(self, variant: IMCKFSW) -> &'a mut W {
        unsafe { self.bits(variant._bits()) }
    }
    #[doc = "Sample frequency ratio set to 32"]
    #[inline]
    pub fn m2sf32(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF32)
    }
    #[doc = "Sample frequency ratio set to 64"]
    #[inline]
    pub fn m2sf64(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF64)
    }
    #[doc = "Sample frequency ratio set to 96"]
    #[inline]
    pub fn m2sf96(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF96)
    }
    #[doc = "Sample frequency ratio set to 128"]
    #[inline]
    pub fn m2sf128(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF128)
    }
    #[doc = "Sample frequency ratio set to 192"]
    #[inline]
    pub fn m2sf192(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF192)
    }
    #[doc = "Sample frequency ratio set to 256"]
    #[inline]
    pub fn m2sf256(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF256)
    }
    #[doc = "Sample frequency ratio set to 384"]
    #[inline]
    pub fn m2sf384(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF384)
    }
    #[doc = "Sample frequency ratio set to 512"]
    #[inline]
    pub fn m2sf512(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF512)
    }
    #[doc = "Sample frequency ratio set to 768"]
    #[inline]
    pub fn m2sf768(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF768)
    }
    #[doc = "Sample frequency ratio set to 1024"]
    #[inline]
    pub fn m2sf1024(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF1024)
    }
    #[doc = "Sample frequency ratio set to 1536"]
    #[inline]
    pub fn m2sf1536(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF1536)
    }
    #[doc = "Sample frequency ratio set to 2048"]
    #[inline]
    pub fn m2sf2048(self) -> &'a mut W {
        self.variant(IMCKFSW::M2SF2048)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub unsafe fn bits(self, value: u8) -> &'a mut W {
        const MASK: u8 = 63;
        const OFFSET: u8 = 24;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _IMCKMODEW<'a> {
    w: &'a mut W,
}
impl<'a> _IMCKMODEW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 30;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
#[doc = r" Proxy"]
pub struct _IWSW<'a> {
    w: &'a mut W,
}
impl<'a> _IWSW<'a> {
    #[doc = r" Sets the field bit"]
    pub fn set_bit(self) -> &'a mut W {
        self.bit(true)
    }
    #[doc = r" Clears the field bit"]
    pub fn clear_bit(self) -> &'a mut W {
        self.bit(false)
    }
    #[doc = r" Writes raw bits to the field"]
    #[inline]
    pub fn bit(self, value: bool) -> &'a mut W {
        const MASK: bool = true;
        const OFFSET: u8 = 31;
        self.w.bits &= !((MASK as u32) << OFFSET);
        self.w.bits |= ((value & MASK) as u32) << OFFSET;
        self.w
    }
}
impl R {
    #[doc = r" Value of the register as raw bits"]
    #[inline]
    pub fn bits(&self) -> u32 {
        self.bits
    }
    #[doc = "Bit 0 - Inter-IC Sound Controller Mode"]
    #[inline]
    pub fn mode(&self) -> MODER {
        MODER::_from({
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        })
    }
    #[doc = "Bits 2:4 - Data Word Length"]
    #[inline]
    pub fn datalength(&self) -> DATALENGTHR {
        DATALENGTHR::_from({
            const MASK: u8 = 7;
            const OFFSET: u8 = 2;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        })
    }
    #[doc = "Bit 8 - Receive Mono"]
    #[inline]
    pub fn rxmono(&self) -> RXMONOR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 8;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        RXMONOR { bits }
    }
    #[doc = "Bit 9 - Single or Multiple DMA Controller Channels for Receiver"]
    #[inline]
    pub fn rxdma(&self) -> RXDMAR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 9;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        RXDMAR { bits }
    }
    #[doc = "Bit 10 - Loopback Test Mode"]
    #[inline]
    pub fn rxloop(&self) -> RXLOOPR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 10;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        RXLOOPR { bits }
    }
    #[doc = "Bit 12 - Transmit Mono"]
    #[inline]
    pub fn txmono(&self) -> TXMONOR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 12;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        TXMONOR { bits }
    }
    #[doc = "Bit 13 - Single or Multiple DMA Controller Channels for Transmitter"]
    #[inline]
    pub fn txdma(&self) -> TXDMAR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 13;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        TXDMAR { bits }
    }
    #[doc = "Bit 14 - Transmit Data when Underrun"]
    #[inline]
    pub fn txsame(&self) -> TXSAMER {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 14;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        TXSAMER { bits }
    }
    #[doc = "Bits 16:21 - Selected Clock to I2SC Master Clock Ratio"]
    #[inline]
    pub fn imckdiv(&self) -> IMCKDIVR {
        let bits = {
            const MASK: u8 = 63;
            const OFFSET: u8 = 16;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        };
        IMCKDIVR { bits }
    }
    #[doc = "Bits 24:29 - Master Clock to fs Ratio"]
    #[inline]
    pub fn imckfs(&self) -> IMCKFSR {
        IMCKFSR::_from({
            const MASK: u8 = 63;
            const OFFSET: u8 = 24;
            ((self.bits >> OFFSET) & MASK as u32) as u8
        })
    }
    #[doc = "Bit 30 - Master Clock Mode"]
    #[inline]
    pub fn imckmode(&self) -> IMCKMODER {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 30;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        IMCKMODER { bits }
    }
    #[doc = "Bit 31 - I2SC_WS Slot Width"]
    #[inline]
    pub fn iws(&self) -> IWSR {
        let bits = {
            const MASK: bool = true;
            const OFFSET: u8 = 31;
            ((self.bits >> OFFSET) & MASK as u32) != 0
        };
        IWSR { bits }
    }
}
impl W {
    #[doc = r" Reset value of the register"]
    #[inline]
    pub fn reset_value() -> W {
        W { bits: 0 }
    }
    #[doc = r" Writes raw bits to the register"]
    #[inline]
    pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
        self.bits = bits;
        self
    }
    #[doc = "Bit 0 - Inter-IC Sound Controller Mode"]
    #[inline]
    pub fn mode(&mut self) -> _MODEW {
        _MODEW { w: self }
    }
    #[doc = "Bits 2:4 - Data Word Length"]
    #[inline]
    pub fn datalength(&mut self) -> _DATALENGTHW {
        _DATALENGTHW { w: self }
    }
    #[doc = "Bit 8 - Receive Mono"]
    #[inline]
    pub fn rxmono(&mut self) -> _RXMONOW {
        _RXMONOW { w: self }
    }
    #[doc = "Bit 9 - Single or Multiple DMA Controller Channels for Receiver"]
    #[inline]
    pub fn rxdma(&mut self) -> _RXDMAW {
        _RXDMAW { w: self }
    }
    #[doc = "Bit 10 - Loopback Test Mode"]
    #[inline]
    pub fn rxloop(&mut self) -> _RXLOOPW {
        _RXLOOPW { w: self }
    }
    #[doc = "Bit 12 - Transmit Mono"]
    #[inline]
    pub fn txmono(&mut self) -> _TXMONOW {
        _TXMONOW { w: self }
    }
    #[doc = "Bit 13 - Single or Multiple DMA Controller Channels for Transmitter"]
    #[inline]
    pub fn txdma(&mut self) -> _TXDMAW {
        _TXDMAW { w: self }
    }
    #[doc = "Bit 14 - Transmit Data when Underrun"]
    #[inline]
    pub fn txsame(&mut self) -> _TXSAMEW {
        _TXSAMEW { w: self }
    }
    #[doc = "Bits 16:21 - Selected Clock to I2SC Master Clock Ratio"]
    #[inline]
    pub fn imckdiv(&mut self) -> _IMCKDIVW {
        _IMCKDIVW { w: self }
    }
    #[doc = "Bits 24:29 - Master Clock to fs Ratio"]
    #[inline]
    pub fn imckfs(&mut self) -> _IMCKFSW {
        _IMCKFSW { w: self }
    }
    #[doc = "Bit 30 - Master Clock Mode"]
    #[inline]
    pub fn imckmode(&mut self) -> _IMCKMODEW {
        _IMCKMODEW { w: self }
    }
    #[doc = "Bit 31 - I2SC_WS Slot Width"]
    #[inline]
    pub fn iws(&mut self) -> _IWSW {
        _IWSW { w: self }
    }
}
